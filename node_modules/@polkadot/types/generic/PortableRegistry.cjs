"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GenericPortableRegistry = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classPrivateFieldLooseBase2 = _interopRequireDefault(require("@babel/runtime/helpers/classPrivateFieldLooseBase"));

var _classPrivateFieldLooseKey2 = _interopRequireDefault(require("@babel/runtime/helpers/classPrivateFieldLooseKey"));

var _util = require("@polkadot/util");

var _Struct = require("../codec/Struct.cjs");

var _getTypeDef = require("../create/getTypeDef.cjs");

var _index = require("../types/index.cjs");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const PRIMITIVE_ALIAS = {
  Char: 'u32',
  // Rust char is 4-bytes
  Str: 'Text'
};
const INK_PRIMITIVE_ALWAYS = ['AccountId', 'AccountIndex', 'Address', 'Balance'];

var _typeDefs = /*#__PURE__*/(0, _classPrivateFieldLooseKey2.default)("typeDefs");

var _createSiDef = /*#__PURE__*/(0, _classPrivateFieldLooseKey2.default)("createSiDef");

var _getLookupId = /*#__PURE__*/(0, _classPrivateFieldLooseKey2.default)("getLookupId");

var _extract = /*#__PURE__*/(0, _classPrivateFieldLooseKey2.default)("extract");

var _extractArray = /*#__PURE__*/(0, _classPrivateFieldLooseKey2.default)("extractArray");

var _extractCompact = /*#__PURE__*/(0, _classPrivateFieldLooseKey2.default)("extractCompact");

var _extractComposite = /*#__PURE__*/(0, _classPrivateFieldLooseKey2.default)("extractComposite");

var _extractFields = /*#__PURE__*/(0, _classPrivateFieldLooseKey2.default)("extractFields");

var _extractPrimitive = /*#__PURE__*/(0, _classPrivateFieldLooseKey2.default)("extractPrimitive");

var _extractPrimitivePath = /*#__PURE__*/(0, _classPrivateFieldLooseKey2.default)("extractPrimitivePath");

var _extractSequence = /*#__PURE__*/(0, _classPrivateFieldLooseKey2.default)("extractSequence");

var _extractTuple = /*#__PURE__*/(0, _classPrivateFieldLooseKey2.default)("extractTuple");

var _extractVariant = /*#__PURE__*/(0, _classPrivateFieldLooseKey2.default)("extractVariant");

var _extractVariantSub = /*#__PURE__*/(0, _classPrivateFieldLooseKey2.default)("extractVariantSub");

class GenericPortableRegistry extends _Struct.Struct {
  constructor(registry, value) {
    super(registry, {
      types: 'Vec<PortableType>'
    }, value);
    Object.defineProperty(this, _extractVariantSub, {
      value: _extractVariantSub2
    });
    Object.defineProperty(this, _extractVariant, {
      value: _extractVariant2
    });
    Object.defineProperty(this, _extractTuple, {
      value: _extractTuple2
    });
    Object.defineProperty(this, _extractSequence, {
      value: _extractSequence2
    });
    Object.defineProperty(this, _extractPrimitivePath, {
      value: _extractPrimitivePath2
    });
    Object.defineProperty(this, _extractPrimitive, {
      value: _extractPrimitive2
    });
    Object.defineProperty(this, _extractFields, {
      value: _extractFields2
    });
    Object.defineProperty(this, _extractComposite, {
      value: _extractComposite2
    });
    Object.defineProperty(this, _extractCompact, {
      value: _extractCompact2
    });
    Object.defineProperty(this, _extractArray, {
      value: _extractArray2
    });
    Object.defineProperty(this, _extract, {
      value: _extract2
    });
    Object.defineProperty(this, _getLookupId, {
      value: _getLookupId2
    });
    Object.defineProperty(this, _createSiDef, {
      value: _createSiDef2
    });
    Object.defineProperty(this, _typeDefs, {
      writable: true,
      value: {}
    });
  }
  /**
   * @description The types of the registry
   */


  get types() {
    return this.get('types');
  }
  /**
   * @description Finds a specific type in the registry
   */


  getSiType(lookupId) {
    const found = this.types[(0, _classPrivateFieldLooseBase2.default)(this, _getLookupId)[_getLookupId](lookupId)];

    (0, _util.assert)(found, () => `PortableRegistry: Unable to find type with lookupId ${lookupId.toString()}`);
    return found.type;
  }
  /**
   * @description Lookup the type definition for the index
   */


  getTypeDef(lookupId) {
    const index = (0, _classPrivateFieldLooseBase2.default)(this, _getLookupId)[_getLookupId](lookupId);

    if (!(0, _classPrivateFieldLooseBase2.default)(this, _typeDefs)[_typeDefs][index]) {
      (0, _classPrivateFieldLooseBase2.default)(this, _typeDefs)[_typeDefs][index] = (0, _classPrivateFieldLooseBase2.default)(this, _extract)[_extract](this.getSiType(lookupId), index);
    }

    return (0, _classPrivateFieldLooseBase2.default)(this, _typeDefs)[_typeDefs][index];
  }

}

exports.GenericPortableRegistry = GenericPortableRegistry;

function _createSiDef2(type) {
  return {
    info: _index.TypeDefInfo.Si,
    type: this.registry.createLookupType(type)
  };
}

function _getLookupId2(lookupId) {
  if ((0, _util.isString)(lookupId)) {
    (0, _util.assert)(this.registry.isLookupType(lookupId), () => `PortableRegistry: Expected a lookup string type, found ${lookupId}`);
    return parseInt(lookupId.replace('Lookup', ''), 10);
  } else if ((0, _util.isNumber)(lookupId)) {
    return lookupId;
  }

  return lookupId.toNumber();
}

function _extract2(type, lookupIndex) {
  var _path$pop;

  const path = [...type.path]; // We handle ink! here as well, although we still have a different registry there

  const isPrimitivePath = !!path.length && (path.length > 2 && path[0].eq('ink_env') && path[1].eq('types') || INK_PRIMITIVE_ALWAYS.includes(path[path.length - 1].toString()));
  let typeDef;

  try {
    if (isPrimitivePath) {
      typeDef = (0, _classPrivateFieldLooseBase2.default)(this, _extractPrimitivePath)[_extractPrimitivePath](lookupIndex, type);
    } else if (type.def.isArray) {
      typeDef = (0, _classPrivateFieldLooseBase2.default)(this, _extractArray)[_extractArray](lookupIndex, type.def.asArray);
    } else if (type.def.isCompact) {
      typeDef = (0, _classPrivateFieldLooseBase2.default)(this, _extractCompact)[_extractCompact](lookupIndex, type.def.asCompact);
    } else if (type.def.isComposite) {
      typeDef = (0, _classPrivateFieldLooseBase2.default)(this, _extractComposite)[_extractComposite](lookupIndex, type.def.asComposite);
    } else if (type.def.isHistoricMetaCompat) {
      typeDef = (0, _getTypeDef.getTypeDef)(type.def.asHistoricMetaCompat);
    } else if (type.def.isPrimitive) {
      typeDef = (0, _classPrivateFieldLooseBase2.default)(this, _extractPrimitive)[_extractPrimitive](lookupIndex, type);
    } else if (type.def.isSequence) {
      typeDef = (0, _classPrivateFieldLooseBase2.default)(this, _extractSequence)[_extractSequence](lookupIndex, type.def.asSequence);
    } else if (type.def.isTuple) {
      typeDef = (0, _classPrivateFieldLooseBase2.default)(this, _extractTuple)[_extractTuple](lookupIndex, type.def.asTuple);
    } else if (type.def.isVariant) {
      typeDef = (0, _classPrivateFieldLooseBase2.default)(this, _extractVariant)[_extractVariant](lookupIndex, type, type.def.asVariant);
    } else {
      throw new Error(`Invalid type at index ${lookupIndex}: No handler for ${type.def.toString()}`);
    }
  } catch (error) {
    throw new Error(`PortableRegistry: Error extracting ${(0, _util.stringify)(type)}: ${error.message}`);
  }

  const displayName = (_path$pop = path.pop()) === null || _path$pop === void 0 ? void 0 : _path$pop.toString();
  return _objectSpread(_objectSpread(_objectSpread({}, displayName ? {
    displayName
  } : {}), path.length > 1 ? {
    namespace: path.map(s => s.toString()).join('::')
  } : {}), typeDef);
}

function _extractArray2(lookupIndex, {
  len: length,
  type
}) {
  (0, _util.assert)(!length || length.toNumber() <= 256, 'PortableRegistry: Only support for [Type; <length>], where length <= 256');
  return {
    info: _index.TypeDefInfo.VecFixed,
    length: length.toNumber(),
    sub: (0, _classPrivateFieldLooseBase2.default)(this, _createSiDef)[_createSiDef](type),
    type: this.registry.createLookupType(lookupIndex)
  };
}

function _extractCompact2(lookupIndex, {
  type
}) {
  return {
    info: _index.TypeDefInfo.Compact,
    sub: (0, _classPrivateFieldLooseBase2.default)(this, _createSiDef)[_createSiDef](type),
    type: this.registry.createLookupType(lookupIndex)
  };
}

function _extractComposite2(lookupIndex, {
  fields
}) {
  return (0, _classPrivateFieldLooseBase2.default)(this, _extractFields)[_extractFields](lookupIndex, fields);
}

function _extractFields2(lookupIndex, fields) {
  const [isStruct, isTuple] = fields.reduce(([isAllNamed, isAllUnnamed], {
    name
  }) => [isAllNamed && name.isSome, isAllUnnamed && name.isNone], [true, true]);
  (0, _util.assert)(isTuple || isStruct, 'PortableRegistry: Invalid fields type detected, expected either Tuple or Struct');

  if (isTuple) {
    if (fields.length === 0) {
      return {
        info: _index.TypeDefInfo.Null,
        type: 'Null'
      };
    } else if (fields.length === 1) {
      return _objectSpread(_objectSpread({}, (0, _classPrivateFieldLooseBase2.default)(this, _createSiDef)[_createSiDef](fields[0].type)), fields[0].name.isSome ? {
        name: (0, _util.stringCamelCase)(fields[0].name.unwrap())
      } : {});
    }
  }

  const sub = fields.map(({
    name,
    type
  }) => _objectSpread(_objectSpread({}, (0, _classPrivateFieldLooseBase2.default)(this, _createSiDef)[_createSiDef](type)), name.isSome ? {
    name: (0, _util.stringCamelCase)(name.unwrap())
  } : {}));
  return {
    info: isTuple // Tuple check first
    ? _index.TypeDefInfo.Tuple : _index.TypeDefInfo.Struct,
    sub,
    type: `(${sub.map(({
      type
    }) => type).join(',')})`
  };
}

function _extractPrimitive2(lookupIndex, type) {
  const typeStr = type.def.asPrimitive.type.toString();
  return {
    info: _index.TypeDefInfo.Plain,
    type: PRIMITIVE_ALIAS[typeStr] || typeStr.toLowerCase()
  };
}

function _extractPrimitivePath2(lookupIndex, type) {
  return {
    info: _index.TypeDefInfo.Plain,
    type: type.path[type.path.length - 1].toString()
  };
}

function _extractSequence2(lookupIndex, {
  type
}) {
  return {
    info: _index.TypeDefInfo.Vec,
    sub: (0, _classPrivateFieldLooseBase2.default)(this, _createSiDef)[_createSiDef](type),
    type: this.registry.createLookupType(lookupIndex)
  };
}

function _extractTuple2(lookupIndex, ids) {
  return ids.length === 1 ? this.getTypeDef(ids[0]) : {
    info: _index.TypeDefInfo.Tuple,
    sub: ids.map(type => (0, _classPrivateFieldLooseBase2.default)(this, _createSiDef)[_createSiDef](type)),
    type: this.registry.createLookupType(lookupIndex)
  };
}

function _extractVariant2(lookupIndex, {
  params,
  path
}, {
  variants
}) {
  const specialVariant = path[0].toString();
  return specialVariant === 'Option' ? {
    info: _index.TypeDefInfo.Option,
    sub: (0, _classPrivateFieldLooseBase2.default)(this, _createSiDef)[_createSiDef](params[0].type.unwrap()),
    type: this.registry.createLookupType(lookupIndex)
  } : specialVariant === 'Result' ? {
    info: _index.TypeDefInfo.Result,
    sub: params.map((p, index) => _objectSpread({
      name: ['Ok', 'Error'][index]
    }, (0, _classPrivateFieldLooseBase2.default)(this, _createSiDef)[_createSiDef](p.type.unwrap()))),
    type: this.registry.createLookupType(lookupIndex)
  } : {
    info: _index.TypeDefInfo.Enum,
    sub: (0, _classPrivateFieldLooseBase2.default)(this, _extractVariantSub)[_extractVariantSub](lookupIndex, variants),
    type: this.registry.createLookupType(lookupIndex)
  };
}

function _extractVariantSub2(lookupIndex, variants) {
  return variants.every(({
    fields
  }) => fields.length === 0) ? variants.map(({
    index,
    name
  }) => ({
    index: index.toNumber(),
    info: _index.TypeDefInfo.Plain,
    name: name.toString(),
    type: 'Null'
  })) : variants.map(({
    fields,
    index,
    name
  }) => _objectSpread(_objectSpread({}, (0, _classPrivateFieldLooseBase2.default)(this, _extractFields)[_extractFields](lookupIndex, fields)), {}, {
    index: index.toNumber(),
    name: name.toString()
  }));
}