import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _classPrivateFieldLooseBase from "@babel/runtime/helpers/esm/classPrivateFieldLooseBase";
import _classPrivateFieldLooseKey from "@babel/runtime/helpers/esm/classPrivateFieldLooseKey";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Copyright 2017-2021 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
import { assert, isNumber, isString, stringCamelCase, stringify } from '@polkadot/util';
import { Struct } from "../codec/Struct.js";
import { getTypeDef } from "../create/getTypeDef.js";
import { TypeDefInfo } from "../types/index.js";
const PRIMITIVE_ALIAS = {
  Char: 'u32',
  // Rust char is 4-bytes
  Str: 'Text'
};
const INK_PRIMITIVE_ALWAYS = ['AccountId', 'AccountIndex', 'Address', 'Balance'];

var _typeDefs = /*#__PURE__*/_classPrivateFieldLooseKey("typeDefs");

var _createSiDef = /*#__PURE__*/_classPrivateFieldLooseKey("createSiDef");

var _getLookupId = /*#__PURE__*/_classPrivateFieldLooseKey("getLookupId");

var _extract = /*#__PURE__*/_classPrivateFieldLooseKey("extract");

var _extractArray = /*#__PURE__*/_classPrivateFieldLooseKey("extractArray");

var _extractCompact = /*#__PURE__*/_classPrivateFieldLooseKey("extractCompact");

var _extractComposite = /*#__PURE__*/_classPrivateFieldLooseKey("extractComposite");

var _extractFields = /*#__PURE__*/_classPrivateFieldLooseKey("extractFields");

var _extractPrimitive = /*#__PURE__*/_classPrivateFieldLooseKey("extractPrimitive");

var _extractPrimitivePath = /*#__PURE__*/_classPrivateFieldLooseKey("extractPrimitivePath");

var _extractSequence = /*#__PURE__*/_classPrivateFieldLooseKey("extractSequence");

var _extractTuple = /*#__PURE__*/_classPrivateFieldLooseKey("extractTuple");

var _extractVariant = /*#__PURE__*/_classPrivateFieldLooseKey("extractVariant");

var _extractVariantSub = /*#__PURE__*/_classPrivateFieldLooseKey("extractVariantSub");

export class GenericPortableRegistry extends Struct {
  constructor(registry, value) {
    super(registry, {
      types: 'Vec<PortableType>'
    }, value);
    Object.defineProperty(this, _extractVariantSub, {
      value: _extractVariantSub2
    });
    Object.defineProperty(this, _extractVariant, {
      value: _extractVariant2
    });
    Object.defineProperty(this, _extractTuple, {
      value: _extractTuple2
    });
    Object.defineProperty(this, _extractSequence, {
      value: _extractSequence2
    });
    Object.defineProperty(this, _extractPrimitivePath, {
      value: _extractPrimitivePath2
    });
    Object.defineProperty(this, _extractPrimitive, {
      value: _extractPrimitive2
    });
    Object.defineProperty(this, _extractFields, {
      value: _extractFields2
    });
    Object.defineProperty(this, _extractComposite, {
      value: _extractComposite2
    });
    Object.defineProperty(this, _extractCompact, {
      value: _extractCompact2
    });
    Object.defineProperty(this, _extractArray, {
      value: _extractArray2
    });
    Object.defineProperty(this, _extract, {
      value: _extract2
    });
    Object.defineProperty(this, _getLookupId, {
      value: _getLookupId2
    });
    Object.defineProperty(this, _createSiDef, {
      value: _createSiDef2
    });
    Object.defineProperty(this, _typeDefs, {
      writable: true,
      value: {}
    });
  }
  /**
   * @description The types of the registry
   */


  get types() {
    return this.get('types');
  }
  /**
   * @description Finds a specific type in the registry
   */


  getSiType(lookupId) {
    const found = this.types[_classPrivateFieldLooseBase(this, _getLookupId)[_getLookupId](lookupId)];

    assert(found, () => `PortableRegistry: Unable to find type with lookupId ${lookupId.toString()}`);
    return found.type;
  }
  /**
   * @description Lookup the type definition for the index
   */


  getTypeDef(lookupId) {
    const index = _classPrivateFieldLooseBase(this, _getLookupId)[_getLookupId](lookupId);

    if (!_classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][index]) {
      _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][index] = _classPrivateFieldLooseBase(this, _extract)[_extract](this.getSiType(lookupId), index);
    }

    return _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][index];
  }

}

function _createSiDef2(type) {
  return {
    info: TypeDefInfo.Si,
    type: this.registry.createLookupType(type)
  };
}

function _getLookupId2(lookupId) {
  if (isString(lookupId)) {
    assert(this.registry.isLookupType(lookupId), () => `PortableRegistry: Expected a lookup string type, found ${lookupId}`);
    return parseInt(lookupId.replace('Lookup', ''), 10);
  } else if (isNumber(lookupId)) {
    return lookupId;
  }

  return lookupId.toNumber();
}

function _extract2(type, lookupIndex) {
  var _path$pop;

  const path = [...type.path]; // We handle ink! here as well, although we still have a different registry there

  const isPrimitivePath = !!path.length && (path.length > 2 && path[0].eq('ink_env') && path[1].eq('types') || INK_PRIMITIVE_ALWAYS.includes(path[path.length - 1].toString()));
  let typeDef;

  try {
    if (isPrimitivePath) {
      typeDef = _classPrivateFieldLooseBase(this, _extractPrimitivePath)[_extractPrimitivePath](lookupIndex, type);
    } else if (type.def.isArray) {
      typeDef = _classPrivateFieldLooseBase(this, _extractArray)[_extractArray](lookupIndex, type.def.asArray);
    } else if (type.def.isCompact) {
      typeDef = _classPrivateFieldLooseBase(this, _extractCompact)[_extractCompact](lookupIndex, type.def.asCompact);
    } else if (type.def.isComposite) {
      typeDef = _classPrivateFieldLooseBase(this, _extractComposite)[_extractComposite](lookupIndex, type.def.asComposite);
    } else if (type.def.isHistoricMetaCompat) {
      typeDef = getTypeDef(type.def.asHistoricMetaCompat);
    } else if (type.def.isPrimitive) {
      typeDef = _classPrivateFieldLooseBase(this, _extractPrimitive)[_extractPrimitive](lookupIndex, type);
    } else if (type.def.isSequence) {
      typeDef = _classPrivateFieldLooseBase(this, _extractSequence)[_extractSequence](lookupIndex, type.def.asSequence);
    } else if (type.def.isTuple) {
      typeDef = _classPrivateFieldLooseBase(this, _extractTuple)[_extractTuple](lookupIndex, type.def.asTuple);
    } else if (type.def.isVariant) {
      typeDef = _classPrivateFieldLooseBase(this, _extractVariant)[_extractVariant](lookupIndex, type, type.def.asVariant);
    } else {
      throw new Error(`Invalid type at index ${lookupIndex}: No handler for ${type.def.toString()}`);
    }
  } catch (error) {
    throw new Error(`PortableRegistry: Error extracting ${stringify(type)}: ${error.message}`);
  }

  const displayName = (_path$pop = path.pop()) === null || _path$pop === void 0 ? void 0 : _path$pop.toString();
  return _objectSpread(_objectSpread(_objectSpread({}, displayName ? {
    displayName
  } : {}), path.length > 1 ? {
    namespace: path.map(s => s.toString()).join('::')
  } : {}), typeDef);
}

function _extractArray2(lookupIndex, {
  len: length,
  type
}) {
  assert(!length || length.toNumber() <= 256, 'PortableRegistry: Only support for [Type; <length>], where length <= 256');
  return {
    info: TypeDefInfo.VecFixed,
    length: length.toNumber(),
    sub: _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type),
    type: this.registry.createLookupType(lookupIndex)
  };
}

function _extractCompact2(lookupIndex, {
  type
}) {
  return {
    info: TypeDefInfo.Compact,
    sub: _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type),
    type: this.registry.createLookupType(lookupIndex)
  };
}

function _extractComposite2(lookupIndex, {
  fields
}) {
  return _classPrivateFieldLooseBase(this, _extractFields)[_extractFields](lookupIndex, fields);
}

function _extractFields2(lookupIndex, fields) {
  const [isStruct, isTuple] = fields.reduce(([isAllNamed, isAllUnnamed], {
    name
  }) => [isAllNamed && name.isSome, isAllUnnamed && name.isNone], [true, true]);
  assert(isTuple || isStruct, 'PortableRegistry: Invalid fields type detected, expected either Tuple or Struct');

  if (isTuple) {
    if (fields.length === 0) {
      return {
        info: TypeDefInfo.Null,
        type: 'Null'
      };
    } else if (fields.length === 1) {
      return _objectSpread(_objectSpread({}, _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](fields[0].type)), fields[0].name.isSome ? {
        name: stringCamelCase(fields[0].name.unwrap())
      } : {});
    }
  }

  const sub = fields.map(({
    name,
    type
  }) => _objectSpread(_objectSpread({}, _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type)), name.isSome ? {
    name: stringCamelCase(name.unwrap())
  } : {}));
  return {
    info: isTuple // Tuple check first
    ? TypeDefInfo.Tuple : TypeDefInfo.Struct,
    sub,
    type: `(${sub.map(({
      type
    }) => type).join(',')})`
  };
}

function _extractPrimitive2(lookupIndex, type) {
  const typeStr = type.def.asPrimitive.type.toString();
  return {
    info: TypeDefInfo.Plain,
    type: PRIMITIVE_ALIAS[typeStr] || typeStr.toLowerCase()
  };
}

function _extractPrimitivePath2(lookupIndex, type) {
  return {
    info: TypeDefInfo.Plain,
    type: type.path[type.path.length - 1].toString()
  };
}

function _extractSequence2(lookupIndex, {
  type
}) {
  return {
    info: TypeDefInfo.Vec,
    sub: _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type),
    type: this.registry.createLookupType(lookupIndex)
  };
}

function _extractTuple2(lookupIndex, ids) {
  return ids.length === 1 ? this.getTypeDef(ids[0]) : {
    info: TypeDefInfo.Tuple,
    sub: ids.map(type => _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type)),
    type: this.registry.createLookupType(lookupIndex)
  };
}

function _extractVariant2(lookupIndex, {
  params,
  path
}, {
  variants
}) {
  const specialVariant = path[0].toString();
  return specialVariant === 'Option' ? {
    info: TypeDefInfo.Option,
    sub: _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](params[0].type.unwrap()),
    type: this.registry.createLookupType(lookupIndex)
  } : specialVariant === 'Result' ? {
    info: TypeDefInfo.Result,
    sub: params.map((p, index) => _objectSpread({
      name: ['Ok', 'Error'][index]
    }, _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](p.type.unwrap()))),
    type: this.registry.createLookupType(lookupIndex)
  } : {
    info: TypeDefInfo.Enum,
    sub: _classPrivateFieldLooseBase(this, _extractVariantSub)[_extractVariantSub](lookupIndex, variants),
    type: this.registry.createLookupType(lookupIndex)
  };
}

function _extractVariantSub2(lookupIndex, variants) {
  return variants.every(({
    fields
  }) => fields.length === 0) ? variants.map(({
    index,
    name
  }) => ({
    index: index.toNumber(),
    info: TypeDefInfo.Plain,
    name: name.toString(),
    type: 'Null'
  })) : variants.map(({
    fields,
    index,
    name
  }) => _objectSpread(_objectSpread({}, _classPrivateFieldLooseBase(this, _extractFields)[_extractFields](lookupIndex, fields)), {}, {
    index: index.toNumber(),
    name: name.toString()
  }));
}